import capture
import layout
import textDisplay
from captureAgents import CaptureAgent

import argparse
import base64
import collections
import datetime
import http
import inspect
import itertools
import json
import logging
import math
import multiprocessing
import os
import pickle
import random
import shutil
import sys
import tempfile
import time
import urllib.error
import urllib.request as request
import zipfile
from contextlib import contextmanager
from typing import Any, AnyStr, IO, Callable, Optional, Self, Sequence
from types import ModuleType


DEFAULT_SECRETS = os.path.join(os.path.dirname(__file__), 'hva.secrets')

# Check if code is run in a (Docker) container.
RUNNING_IN_CONTAINER = bool(int(os.environ.get("RUNNING_IN_CONTAINER", 0)))

DATA_PATH = os.path.dirname(__file__)
if RUNNING_IN_CONTAINER:
    DATA_PATH = "/data"

LOG_FILENAME = os.path.join(DATA_PATH, 'log.txt')
LOG_FORMAT = "%(asctime)s %(module)s %(levelname)s %(message)s"

logging.basicConfig(filename=LOG_FILENAME,
        filemode="w+",
        format=LOG_FORMAT,
        level=logging.DEBUG)

SECRETS_KEYS = [ # (name, description, args_requiring_this_secret)
        ('course_name', "Course name", []),
        ('flow_latest_modified', "Flow URL that sends the timestamp of the latest remote student data", ["do_download"]),
        ('flow_create_student_chunks', "Flow URL to chunkify remote data", ["do_download"]),
        ('flow_transfer_student_chunk', "Flow URL to download student chunks", ["do_download"]),
        ('flow_transfer_results_chunk', "Flow URL to upload a chunk of a file", ["send_message"]),
        ('flow_notify', "Flow URL that notifies students about new results", ["send_message"]),
]

FLOW_SIGNATURES = {
    'flow_latest_modified': {'method': 'GET', 
                             'input': [],
                             'output': {'latest_modification': datetime.datetime.fromisoformat}},
    'flow_create_student_chunks': {'method': 'POST',
                                   'input': ['chunk_size'],
                                   'output': {'chunks': int}},
    'flow_transfer_student_chunk': {'method': 'POST',
                                    'input': ['chunk'],
                                    'output': {"content": str}},
    'flow_transfer_results_chunk': {'method': 'POST',
                                    'input': ['filename', 'content', 'chunk_index', 'final_chunk'],
                                    'output': {}},
    'flow_notify': {'method': 'POST',
                    'input': ['filename'],
                    'output': {}}
}

TIMESTAMP_FMT = "%Y-%m-%d.%H-%M-%S"


## LOGGING

def create_match_log(dir: str, matchno: int,
                     red_name: str, blue_name: str,
                     filemode="w+",
                     format=LOG_FORMAT,
                     level=logging.DEBUG) -> logging.Logger:
    """
    Create a match-specific log file for data generated by two teams.
    """
    log_name = f"{matchno}.{red_name}.{blue_name}"
    log_file = f"{dir}/log-{matchno}-{red_name}-{blue_name}.txt"

    handler = logging.FileHandler(log_file, mode=filemode)
    formatter = logging.Formatter(format)
    handler.setFormatter(formatter)

    logger = logging.getLogger(log_name)
    logger.setLevel(level)
    logger.propagate = False
    logger.addHandler(handler)

    return logger


class LogAsStream:
    """
    Change a log into a streamable object.

    This is a utility for @contextmanager.
    """
    def __init__(self, log_name: str, log_level: int, prefix='') -> None:
        self._logger = logging.getLogger(log_name)
        self._level = log_level
        self._prefix = prefix or ''

    def write(self, buf: str) -> None:
        lines = buf.rstrip().splitlines()
        for line in lines:
            self._logger.log(self._level, self._prefix + line.rstrip())


@contextmanager
def replace_stdout(stream: IO[AnyStr]) -> IO[AnyStr]:
    """
    Temporarily swap another streamable object for stdout.
    """
    old_stdout, sys.stdout = sys.stdout, stream
    try:
        yield stream
    finally:
        sys.stdout = old_stdout


@contextmanager
def replace_stderr(stream: IO[AnyStr]) -> IO[AnyStr]:
    """
    Temporarily swap another streamable object for stderr.
    """
    old_stderr, sys.stderr = sys.stderr, stream
    try:
        yield stream
    finally:
        sys.stderr = old_stderr


def log_stdout(logname='STDOUT', prefix='') -> IO[AnyStr]:
    """
    Temporarily let the output of print() be logged.
    """
    return replace_stdout(LogAsStream(logname, logging.DEBUG, prefix=prefix))


def log_stderr(logname='STDERR', prefix='') -> IO[AnyStr]:
    """
    """
    return replace_stderr(LogAsStream(logname, logging.WARN, prefix=prefix))


def silence_stdout() -> IO[AnyStr]:
    """
    Temporarily set the output of print() to nothing.
    """
    return replace_stdout(open(os.devnull, 'w'))


def mute_agents(agents: list[CaptureAgent]) -> list[CaptureAgent]:
    """
    When agents want to print(), do nothing instead.
    """
    def silencer(fn):
        def silenced(*args, **kwargs):
            with silence_stdout():
                return fn(*args, **kwargs)
        return silenced
    muted_agents = []
    for agent in agents:
        agent.registerInitialState = silencer(agent.registerInitialState)
        agent.chooseAction = silencer(agent.chooseAction)
        muted_agents.append(agent)
    return muted_agents


## SECRETS

SecretsType = dict[str, str]

def create_secrets(secrets_file=DEFAULT_SECRETS) -> None:
    """
    Create a secrets file.

    Instead of storing secret information, such as login credentials, publicly
    in this file, we store them in a separate file.  That way, we can easily
    share this file with others, without accidentally sharing private
    information.
    """
    print("We are going to make a new secrets file. \n"
          f"If {secrets_file} already exsists, we will try to recover information from "
          "that file when the reply is empty.")

    secrets: SecretsType = {}
    try:
        with open(secrets_file, 'rb') as f:
            secrets = pickle.load(f)
    except (OSError, pickle.PickleError):
        pass
    for key, prompt, _ in SECRETS_KEYS:
        if key in secrets:
            prompt += f" (now: \"{secrets[key]}\")"
        secrets[key] = input(prompt + ": ").strip() or secrets.get(key, '')
    with open(secrets_file, 'wb') as f:
        pickle.dump(secrets, f)


def load_secrets(secrets_file=DEFAULT_SECRETS, args: argparse.Namespace = None) -> SecretsType:
    """
    Load data from a secrets file and check if all required fields are
    present.
    """
    try:
        with open(secrets_file, 'rb') as f:
            secrets = pickle.load(f)
    except FileNotFoundError:
        logging.warning("No such secrets file: {}  "
                        "Working with an empty collection of secrets."
                        .format(secrets_file))
        secrets: SecretsType = {}
    missing = []
    if args is not None:
        for key, _, requesting_args in SECRETS_KEYS:
            if key not in secrets:
                args_requesting_this_key = [arg for arg in requesting_args if getattr(args, arg)]
                if args_requesting_this_key:
                    missing.append((key, args_requesting_this_key))
    if missing:
        missing_str = ""
        for key, requesting_args in missing:
            missing_str += f"\n  - {key}: " + ", ".join(f"--{arg}" for arg in requesting_args)
        msg = f"Missing secret values for the following items, and their requiring arguments: {missing_str}"
        raise RuntimeError(msg)
    return secrets


def cleanup_secrets(secrets_file=DEFAULT_SECRETS) -> None:
    """
    Remove unused keys from a secrets file.

    Used keys are those available in SECRETS_KEYS.  Unused keys might occur
    after an update to the system.
    """
    with open(secrets_file, 'rb') as f:
        secrets = pickle.load(f)
    used_keys = {key for (key, _, _) in SECRETS_KEYS}
    old_keys = secrets.keys() - used_keys
    logging.debug(f"Removing the following outdated keys from secrets file {secrets_file}:")
    logging.debug(f"  {', '.join(old_keys)}")
    for old_key in old_keys:
        del secrets[old_key]
    with open(secrets_file, 'wb') as f:
        pickle.dump(secrets, f)


def are_secrets_available(secrets: SecretsType, requests: list[str]) -> bool:
    """
    Tests if some requested keys in secrets are available and set.

    When a secrets file is created with --edit-secrets, all keys are
    placed into the resulting file.  This results in that `key in secrets`
    does not inform you if that key is really set.

    This function tests for each key in requests, if it is in secrets, and if
    it's not set to the empty string.
    """
    return all(r in secrets and secrets[r] != '' for r in requests)


## MICROSOFT FLOW RELATED FUNCTIONS

def call_flow(secrets: SecretsType, key: str, **kwargs) -> dict:
    """
    Makes an HTTP request call to a Microsoft Flow process.

    The Flow URL should be stored in secrets by its key.  Its 
    calling signature should be described in FLOW_SIGNATURES.
    There you will find the required ;

    Multiple exceptions can be raised:
        - NameError, if the key is not described by FLOW_SIGNATURES.
        - RuntimeError, if the key is not in secrets.
        - TypeError, when one or more key word arguments are supplied.
        - urllib.error.HTTPError, when the Flow URL could not be opened,
            or when the Flow returns an HTTP error status (400 and above).
    """
    # Check if key is known.
    if key not in FLOW_SIGNATURES.keys():
        raise NameError(f"Unknown flow key: '{key}'", name=key)
    if key not in secrets or secrets[key] == '':
        raise RuntimeError(f"Unknown secret: '{key}'")
    
    # Check if number of arguments are correct.
    signature = FLOW_SIGNATURES[key]
    args_count = len(signature['input'])
    if args_count != len(kwargs):
        if args_count == 0:
            raise TypeError(f"call_flow(...) with key='{key}' requires {args_count} keyword arguments")
        else:
            args = ", ".join(signature['input'])
            raise TypeError(f"call_flow(...) with key='{key}' requires {args_count} keyword arguments: {args}")

    # Check if argument names are correct, and start building data block.
    if args_count == 0:
        data = None
    else:
        data = {}
        for arg in signature['input']:
            if arg not in kwargs:
                args = ", ".join(signature['input'])
                raise TypeError(f"call_flow(...) with key='{key}' requires {args_count} keyword arguments: {args}")
            data[arg] = kwargs[arg]
        data = json.dumps(data).encode('utf-8')

    headers = {'Content-type': 'application/json'}

    # Make the call to the Flow.
    req = request.Request(secrets[key],
                          data=data,
                          headers=headers,
                          method=signature['method'])
    response = request.urlopen(req)

    # Parse the returned JSON object to a dict.
    if not signature['output']:
        return {}
    def hook(data: dict[Any, Any]) -> dict[Any, Any]:
        return {k: signature['output'].get(k, lambda x: x)(v) for k, v in data.items()}
    return json.load(response, object_hook=hook)


## ARGPARSE-RELATED FUNCTIONS

def check_positive(value: Any) -> bool:
    """
    argparse helper function to make sure values are > 0.
    """
    ivalue = int(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError(f"""{value} is negative or zero, but should
        be positive.""")
    return ivalue


def check_positive_or_zero(value: Any) -> bool:
    """
    argparse helper function to make sure values are >= 0.
    """
    ivalue = int(value)
    if ivalue < 0:
        raise argparse.ArgumentTypeError(f"""{value} is negative, but should be
                positive or zero.""")
    return ivalue


def check_is_file(value: Any) -> bool:
    """
    argparse helper function to make sure value is a path to an exisiting
    file.
    """
    if not os.path.isfile(value) and value is not DEFAULT_SECRETS:
        raise argparse.ArgumentTypeError(f"{value} is not a file name")
    return value


def parse_arguments() -> argparse.Namespace:
    """
    Parse command line arguments, and provides text for --help.

    These will be in a form that the original game can process.
    """
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)


    # competition.py-specific arguments.
    parser.add_argument("-A", "--agent-args", dest="agentArgs",
            help="""Options for each agent in a game (e.g.,
            key1=value1,key2=value2,...)""")
    parser.add_argument("-d", "--download", dest="do_download",
                        action="store_true",
                        help="""Download new student data.
                        This requires a working secrets file.""")
    parser.add_argument("-b", "--add-baseline", dest="add_baseline",
                        action="store_true",
                        help="Add baselineTeam to the participants pool.")
    parser.add_argument("-m", "--send-message", dest="send_message",
                        action="store_true",
                        help="""Notify participants of new results.
                        This requires a working secrets file.""")
    parser.add_argument("-p", "--play-matches", dest="play_matches",
                        action="store_true",
                        help="""Play a competition.  This is probably you are
                        looking for.  All available teams in students/ will run
                        matches against eachother in a round robin
                        tournament setup.""")

    parser.add_argument("-S", "--edit-secrets", dest="edit_secrets",
            action="store_true",
            help="Edit or create the secrets file. No competition is played.")
    parser.add_argument("-T", "--threads", dest="threads",
            type=check_positive_or_zero, default=multiprocessing.cpu_count()-1,
            help="""Number of threads used for running matches.""")

    parser.add_argument("-F", "--focus_team", dest="focus",
            default=False, help="""Only play matches with this team.""")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--remove-zip", dest="remove_zip",
                       action="store_true",
                        help="Remove local zip file after uploading to the cloud.")
    group.add_argument("--keep-zip", dest="remove_zip",
                        action="store_const", const=False,
                        help="Keep local zip file after uploading to the cloud.")

    # capture.py-specific arguments.
    parser.add_argument("-l", "--layout", dest="layout",
            default="defaultCapture",
            help="""The layout file from which to load the map layout; use
            RANDOM for a random maze; use RANDOM<seed> to use a specified
            random seeg, e.g., RANDOM23.""")
    parser.add_argument("-q", "--quiet", dest="display_type",
            action="store_const", const="quiet",
            help="Display minimal output and no graphics.")
    parser.add_argument("-Q", "--super-quiet", dest="display_type",
            action="store_const", const="super_quiet",
            help="Same as -q but agent output is also suppressed.")
    parser.add_argument("-i", "--time", dest="length",
            type=check_positive, default=1200,
            help="Time limit of a game in moves.")
    parser.add_argument("-n", "--numGames", dest="numGames",
            type=check_positive, default=1,
            help="Number of games to play.")
    parser.add_argument("-f", "--fixRandomSeed", dest="fixRandomSeed",
            action="store_true",
            help="Fixes the random seed to always play the same game.")
    parser.add_argument("--record", dest="record",
            action="store_true", default=True,
            help="Writes game histories to a file (named RedTeam-BlueTeam).")
    parser.add_argument("-x", "--num-training", dest="numTraining",
            type=check_positive_or_zero, default=0,
            help="How many episodes are training (suppresses output).")
    parser.add_argument("-c", "--catch-exceptions", dest="catchExceptions",
            action="store_true", default=True,
            help="Catch exceptions and enforce time limits.")
    parser.add_argument("-s", "--secrets", dest="secrets",
            type=check_is_file, default=DEFAULT_SECRETS,
            help="File containing the 'secret' infomation.")

    args = parser.parse_args()

    if args.display_type == "quiet":
        args.display_fn = textDisplay.NoGraphics
    elif args.display_type == "super_quiet":
        args.display_fn = textDisplay.NoGraphics
        args.muteAgents = True
    else:
        args.display_fn = textDisplay.PacmanGraphics

    if args.layout.startswith("RANDOM") and len(args.layout) > 6:
    #if args.layout == "RANDOM":
    #    args.layout_type = ("random", None)
    #elif args.layout.startswith("RANDOM"):
        seed = args.layout[6:]
        if seed.isdigit():
            seed = int(seed)
        args.layout_type = ("random", seed)
    else:
        if args.layout == "RANDOM":
            args.layout = getRandomLayout()
        _layout = layout.getLayout(args.layout)
        if _layout is None:
            raise Exception(f"The layout '{args.layout}' cannot be found in "
                    "folder layouts/")
        args.layout_type = ("map", _layout)

    agent_args = capture.parseAgentArgs(args.agentArgs)
    args.agentArgs = agent_args

    args.delay_step = 0
    return args


## COMPETITION: HELPER FUNCTIONS

def getRandomLayout() -> str:
    layouts_dir = os.path.join(os.path.dirname(__file__), 'layouts')
    layouts = list(filter(lambda f: not f.startswith('.') and f.endswith('.lay'),
                          os.listdir(layouts_dir)))
    random_layout = random.choice(layouts)
    # Strip extension, if present
    name_elements = random_layout.split(os.extsep)
    if name_elements[-1] == 'lay':
        random_layout = os.extsep.join(name_elements[:-1])
    return random_layout


def update_arguments(args: argparse.Namespace,
                     red_name: str, red_agents: list[CaptureAgent],
                     blue_name: str, blue_agents: list[CaptureAgent]) -> dict[str, Any]:
    """
    Give a matchup-specific update on the command line arguments.

    Again, these will be in a form that the original game can process.
    """
    # This will be a list of agents [r1, b1, r2, b2, ...].
    agents = sum([list(el) for el in zip(red_agents, blue_agents)], [])

    layouts = []
    for _ in range(args.numGames):
        if args.layout_type[0] == "random":
            seed = args.layout_type[1]
            _layout = layout.Layout(capture.randomLayout(seed).split('\n'))
        else:
            _layout = args.layout_type[1]
        layouts.append(_layout)

    vargs = vars(args)
    return {
            "layouts": layouts,
            "agents": agents,
            "display": args.display_fn(),
            "length": args.length,
            "numGames": args.numGames,
            "record": args.record,
            "numTraining": args.numTraining,
            "redTeamName": red_name,
            "blueTeamName": blue_name,
            "muteAgents": vargs.get("muteAgent", False),
            "catchExceptions": vargs.get("catchExceptions", False),
            "delay_step": vargs.get("delay_step", 0),
            }


## COMPETITION: DATA REPRESENTATIONS

AgentFactoryType = Callable[[int, int, bool], Sequence[CaptureAgent]]

class Result:
    """
    Represents both the game outcomes and the corresponding score multipliers.
    """
    WIN = 5
    TIE = 3
    LOST = 1
    ERROR = -6

    @classmethod
    def get_name(cls, number: int) -> str:
        """
        Get a string representation of a Result value.
        """
        for member in dir(cls):
            if getattr(cls, member) == number:
                return member
        raise RuntimeError(f"Unknown Result type: {number}")

    @classmethod
    def from_points(cls, points: int, error=False) -> tuple[int, int]:
        r1 = cls.WIN
        r2 = cls.LOST
        if points < 0:
            r1 = cls.LOST
            r2 = cls.WIN
        elif points > 0:
            r1 = cls.WIN
            r2 = cls.LOST
        else:
            r1 = cls.TIE
            r2 = cls.TIE

        if error:
            if r1 != cls.WIN:
                r1 = cls.ERROR
            if r2 != cls.WIN:
                r2 = cls.ERROR

        return r1, r2


class StudentError:
    """
    Disqualifying errors and their string representation.
    """
    CannotImport = "Error during import: {}"
    NoCreateTeam = "No createTeam function found."
    CreateTeamTooFewArgs = "createTeam has too few arguments."
    CreateTeamTooManyNondefaults = "createTeam has too many arguments without parameters."
    CreateTeamRuntime = "createTeam ran into a RuntimeException."
    CreateTeamNoReturn = "createTeam returned nothing or None."
    createTeamWrongReturn = "createTeam did not return an indexable collection of 2 objects."


class Record:
    """
    Stores the frequencies of a team's game outcomes.
    """
    def __init__(self, win=0, tie=0, lost=0, error=0, points=0) -> None:
        self._counter = collections.Counter()
        self._counter[Result.WIN] = win
        self._counter[Result.TIE] = tie
        self._counter[Result.LOST] = lost
        self._counter[Result.ERROR] = error
        self.points = points


    @property
    def win(self) -> int:
        return self._counter[Result.WIN]

    @property
    def tie(self) -> int:
        return self._counter[Result.TIE]

    @property
    def lost(self):
        return self._counter[Result.LOST]

    @property
    def error(self) -> int:
        return self._counter[Result.ERROR]

    def score(self) -> int:
        """
        Computes the score of this team.

        The score is a sum product of the result frequencies with their
        corresponding score multipliers.
        """
        return sum(map(lambda k: k * self._counter[k],
            self._counter))

    def update(self, points: int, result: Optional[Result] = None) -> None:
        """
        Stores an occurance of a Result type.
        """
        if result is None:
            result, _ = Result.from_points(points)
        # See if result is a member of Result
        Result.get_name(result)
        self._counter[result] += 1
        self.points += points

    def __repr__(self) -> str:
        """
        Gives a human-readable representation of Record.
        """
        name = self.__class__.__name__
        win = self._counter[Result.WIN]
        tie = self._counter[Result.TIE]
        lost = self._counter[Result.LOST]
        error = self._counter[Result.ERROR]
        points = self.points
        return (f"{name}(win={win}, tie={tie}, lost={lost}, "
                f"error={error}, points={points})")

    def __cmp__(self, other: Any) -> int:
        """
        Makes Records sortable.
        """
        if type(self) is not type(other):
            return -1
        a = self.points
        b = other.points
        if self.score() != other.score():
            a = self.score()
            b = other.score()
        return (a > b) - (a < b)

    def __lt__(self, other: Any) -> bool:
        """
        Defines self < other.
        """
        return self.__cmp__(other) < 0

    def __le__(self, other: Any) -> bool:
        """
        Defines self <= other.
        """
        return self.__cmp__(other) <= 0

    def __gt__(self, other: Any) -> bool:
        """
        Defines self > other.
        """
        return self.__cmp__(other) > 0

    def __ge__(self, other: Any) -> bool:
        """
        Defines self >= other.
        """
        return self.__cmp__(other) >= 0

    def __add__(self, other: Any) -> Self:
        """
        Implements operator + for 2 Record objects.

        """
        if type(self) is not type(other):
            c1 = self.__class__
            c2 = other.__class__
            raise TypeError(f"unsupported operand type(s) for +: '{c1}' and '{c2}'")
        counter = self._counter + other._counter
        points = self.points + other.points
        return self.__class__(win=counter[Result.WIN],
                tie=counter[Result.TIE],
                lost=counter[Result.LOST],
                error=counter[Result.ERROR],
                points=points)


class Scoreboard:
    def __init__(self) -> None:
        self.disqualified_teams: dict[str, str] = {}
        self._participating_teams: dict[str, AgentFactoryType] = {}
        self.records = collections.defaultdict(
                lambda: collections.defaultdict(Record))
        self._lock = multiprocessing.Lock()
        self._records_count = 0

    def disqualify(self, teams: dict[str, str]) -> None:
        """
        Registers all teams disqualified by initial inspection.

        teams is a dictionary.  The keys should be the teams' names, and its
        values are strings with a human-readable description of the error.
        """
        with self._lock:
            self.disqualified_teams.update(teams)

    def register_participants(self, teams: dict[str, AgentFactoryType]) -> None:
        """
        Register a collection of team names as participants.

        teams is a dictionary.  The keys should be the teams' names, and its
        values are the factory to create the team's agents.
        """
        with self._lock:
            self._participating_teams.update(teams)

    def add_result(self, leftTeam: str, rightTeam: str, points: int,
                   leftResult: Optional[Result] = None,
                   rightResult: Optional[Result] = None) -> None:
        """
        Adds scores to the score board.
        """
        with self._lock:
            self.records[leftTeam][rightTeam].update(points, leftResult)
            self.records[rightTeam][leftTeam].update(-points, rightResult)
            self._records_count += 1

    def ranking(self) -> list[str, Record]:
        """
        Returns a list of team names, sorted by highest-ranking teams first.
        """
        totals = []
        for team in self.records.keys():
            totals.append((team, sum(self.records[team].values(), Record())))
        return sorted(totals, key=lambda x: x[1], reverse=True)

    def make_pairings(self, focus: Optional[str] = None) -> multiprocessing.Queue:
        """
        Generate all game pairings of all participants.

        Each team plays against each other team a single time.  The team's home
        side is randomized.

        The returned value is a multiprocessing.Queue.  Initially, it contains
        n! / 2! / (n - 2)! items, with n = len(self.participants)

        When focus is provided and it is in self._participating_teams, only games
        in which that team occurs are played, where that team is both red and
        blue for each opponent.  The returned multiprocessing.Queue then only
        contains 2*n-2 pairings, with n = len(self.participants).
        """
        def _shuffled(x):
            y = list(x)
            random.shuffle(y)
            return y
        queue = multiprocessing.Queue()
        if focus:
            if focus in self._participating_teams:
                focused_team = focus, self._participating_teams[focus]
                for other_name, other_factory in self._participating_teams.items():
                    if other_name != focus:
                        queue.put((focused_team, (other_name, other_factory)))
                        queue.put(((other_name, other_factory), focused_team))
            return queue
        combinations = itertools.combinations(self._participating_teams.items(), 2)
        for match in combinations:
            queue.put(_shuffled(match))
        return queue

    @property
    def participants(self) -> list[str]:
        """
        Returns an alphabetically sorted list of team names.
        """
        return sorted(list(self._participating_teams.keys()))

    @property
    def student_participants(self) -> list[str]:
        """
        Returns the number of "real" participants, that is: student hand-ins.

        Not-so-real participants are those whose names start with either "[git]"
        or "veteran", case-insensitive.  Also, "baselineTeam" is ignored.
        """
        return sorted(list(filter(lambda x: not x.lower().startswith('[git]')
                                            and not x.lower().startswith('veteran')
                                            and not x.lower() == "baselineteam",
            self._participating_teams.keys())))

    def __len__(self) -> int:
        """
        Returns the number of stored records.
        """
        with self._lock:
            return self._records_count


## COMPETITION: RETRIEVE STUDENT DATA

def cloud_has_new_student_data(secrets: SecretsType) -> bool:
    """
    Check if remote contains new student data.

    To do this, we need two pieces of data:
    - Locally, the file DATA_PATH/_latest_modification stores the locally 
      known latest modification.  This has been retrieved from an earlier
      call to this function.

    - Remotely, we get the information from a Microsoft Flow.  This Flow
      returns a JSON object with member 'latest_modification' containing a
      timestamp.
    
    This function returns True iff the timestamp from the remote server is
    of a later moment than the locally stored information.

    For this, the following secrets are required:
        - flow_latests_modified
    """
    if not are_secrets_available(secrets, ['flow_latest_modified']):
        logging.warning("No secrets information available to get the latest "
                        "student modifications.  Assumed that we're outdated")
        return True

    # Get latest local modification timestamp
    local_latest = datetime.datetime(1, 1, 1, tzinfo=datetime.timezone.utc)
    local_mod_file = os.path.join(DATA_PATH, ".latest_modification.json")
    if os.path.isfile(local_mod_file):
        try:
            with open(local_mod_file) as f:
                local_json = json.load(f)
            local_timestamp = local_json['latest_modification']
            local_latest = datetime.datetime.fromisoformat(local_timestamp)
        except (OSError, json.decoder.JSONDecodeError, ValueError):
            pass

    # Get latest remote modification timestamp
    response = call_flow(secrets, 'flow_latest_modified')
    remote_latest: datetime.datetime = response['latest_modification']
    if remote_latest > local_latest:
        json.dump({'latest_modification': remote_latest.isoformat()}, open(local_mod_file, 'w'))
        return True
    return False


def create_remote_student_chunks(secrets: SecretsType, chunk_size=10*2**20) -> int:
    """
    Prepares the remote SharePoint environment for chunked download of student files.
    
    When called, a Flow will perform the following steps on the remote:
        - Remove all old chunk files.
        - Create an empty variable all_data
        - For each student hand-in with filename n and base64-encoded content c, 
          append f"|{n}:{c}" to all_data.
        - Slice up all_data in chunks of chunk_size bytes each.
        - Store each chunk as a file, that can be retrieved by its index.

    This function returns the number of chunk files available for download.

    For this, the following secrets are required:
        - flow_create_student_chunks
    """
    logging.debug("Create chunks on the remote server")
    reply = call_flow(secrets, 'flow_create_student_chunks', chunk_size=chunk_size)
    chunks = reply['chunks']
    logging.debug(f"There are {chunks} remote chunks")
    return chunks


def get_student_chunks(secrets: SecretsType, chunks: int) -> str | bytes:
    """
    Retrieves all chunks from the SharePoint environment, containing student data.

    For how these chunks are created, see create_remote_students_chunks(...).
    For how to decode these chunks into files, see create_student_files(...).

    For this, the following secrets are required:
        - flow_transfer_student_chunk
    """
    data = ""
    for chunk in range(chunks):
        logging.debug(f"Downloading chunk {chunk+1} of {chunks}...")
        reply = call_flow(secrets, 'flow_transfer_student_chunk', chunk=chunk)
        data += reply['content']
    logging.info("Downloading has finished!")
    return data


def remove_student_files(student_data_dir: str) -> None:
    """
    Removes old student data.
    """
    logging.info("Removing the old student data directory.")
    if os.path.exists(student_data_dir):
        shutil.rmtree(student_data_dir)
    os.mkdir(student_data_dir)


def create_student_files(data: str | bytes, output_dir: str) -> list[str]:
    """
    Create student files from chunk data in output_dir.

    The chunk data is a string that contains the pattern /(|.*:.*)*/,
    or f"|{name}:{encoded_data}" (which is repeated 0 or more times).
    This function creates new files named output_dir/name, and places the
    base64-decoded content in it.

    A list of created file names (without folder information) is returned.
    """
    SEPARATOR_FILES = "|"
    SEPARATOR_NAME_DATA = ":"

    files_created = []
    for student_data in data.split(SEPARATOR_FILES):
        try:
            filename, encoded_content = student_data.split(SEPARATOR_NAME_DATA)
            decoded_content = base64.b64decode(encoded_content)
            with open(os.path.join(output_dir, filename), 'wb') as f:
                f.write(decoded_content)
            files_created.append(filename)
        except ValueError:
            if student_data:
                logging.warning(f"Could not interpret data: {student_data}")
            continue
    return files_created


def restore_students_init(student_data_dir: str) -> None:
    """
    Restores students/__init__.py.
    """
    logging.info("Restoring students/__init__.py.")
    init_file = os.path.join(os.path.dirname(__file__), '_students_init.py')

    if not os.path.exists(student_data_dir):
        os.mkdir(student_data_dir)
    shutil.copy(init_file,
                os.path.join(student_data_dir, "__init__.py"))
    logging.info("Restoring students/__init__.py succesful.")


def receive_student_data(secrets: SecretsType) -> bool:
    """
    Download student data by interacting with Flow.  Returns True if there
    is new student data.
    
    For this, the following secrets are required:
        - flow_latest_modified
        - flow_create_student_chunks
        - flow_transfer_student_chunk
    """
    if not are_secrets_available(secrets, ['flow_latest_modified',
                                           'flow_create_student_chunks',
                                           'flow_transfer_student_chunk']):
        logging.warning("Secret information for receiving student data insufficient.  "
                        "Student data is not received.")
        return False

    if cloud_has_new_student_data(secrets):
        logging.info("New student data available")
        students_dir = os.path.join(DATA_PATH, 'students')

        ATTEMPTS = 3
        for attempt in range(ATTEMPTS):
            try:
                chunks = create_remote_student_chunks(secrets)
                student_chunks = get_student_chunks(secrets, chunks)
            except urllib.error.HTTPError as e:
                if e.code == http.HTTPStatus.GATEWAY_TIMEOUT and attempt+1 < ATTEMPTS:
                    logging.debug(f"Flow timed out: {e}")
                    continue
                else:
                    raise e
            else:
                break

        remove_student_files(students_dir)
        student_files = create_student_files(student_chunks, students_dir)
        restore_students_init(students_dir)
        return bool(student_files)
    else:
        logging.info("No new student data")
        return False


## COMPETITION: PROCESS STUDENT DATA

def add_baseline_to_pool(secrets: SecretsType) -> None:
    """
    Copies baselineTeam.py to the students/ directory as a participating team.
    """
    src_file = os.path.join(os.path.dirname(__file__),
                            'baselineTeam.py')
    dest_dir = os.path.join(DATA_PATH, 'students')
    shutil.copy(src_file, dest_dir)


def get_student_modules(module: ModuleType) -> list[ModuleType]:
    """
    Retrieve all submodules from a module.
    """
    submodules = []
    for item in dir(module):
        if item.startswith('_'):
            continue
        member = getattr(module, item)
        if isinstance(member, type(module)):
            submodules.append(member)
    return submodules


def analyse_student_modules(student_modules: list[ModuleType]) -> tuple[dict[str, AgentFactoryType],
                                                                        dict[str, str]]:
    """
    Find out which modules work as expected.

    This function will return two values:
    - a list of agent factories contained in the modules that stick to the
      rules.
    - a list of ModuleErrors for modules not sticking to the rules.
    """
    agent_factories: dict[str, AgentFactoryType] = {}
    disqualified_teams: dict[str, str] = {}
    for student_module in student_modules:
        module_name = student_module.__name__
        team_name = '.'.join(module_name.split('.')[1:])
        error = None

        if not hasattr(student_module, "createTeam"):
            error = StudentError.NoCreateTeam
        else:
            createTeam = getattr(student_module, "createTeam")
            team_red = None
            team_blue = None
            try:
                with silence_stdout():
                    team_red = createTeam(0, 1, True)
                    team_blue = createTeam(2, 3, False)
            except Exception:
                arg_spec = inspect.getfullargspec(createTeam)
                all_args = len(arg_spec.args)
                nondefault_args = all_args - len(arg_spec.defaults)
                if all_args < 3:
                    error = StudentError.CreateTeamTooFewArgs
                elif nondefault_args > 3:
                    error = StudentError.CreateTeamTooManyNondefaults
                else:
                    error = StudentError.CreateTeamRuntime

            if None in (team_red, team_blue) and error is not None:
                error = StudentError.CreateTeamNoReturn
            else:
                try:
                    if len(team_red) != 2 or len(team_blue) != 2:
                        raise TypeError(StudentError.CreateTeamWrongReturn)
                except TypeError:
                    error = StudentError.CreateTeamWrongReturn
        if error:
            disqualified_teams[team_name] = error
        else:
            agent_factories[team_name] = createTeam

    return agent_factories, disqualified_teams


## COMPETITION: GENERATE OUTPUT

def generate_html_report(scoreboard: str, report_file: str, course_name: str,
                         timestamp_start: datetime.datetime,
                         timestamp_finish: datetime.datetime,
                         layout: str, layout_type: tuple[str, int],
                         **args: Any) -> None:
    """
    Make an HTML document that will represent the score in scoreboard.
    """
    fmt = {}
    fmt['courseName'] = course_name
    fmt['timestamp_start'] = timestamp_start
    fmt['timestamp_finish'] = timestamp_finish
    fmt['layout_name'] = layout
    fmt['argv'] = sys.argv

    fmt['title'] = f"{course_name} Capture the Flag results of {timestamp_start:%d-%m-%Y}"
    fmt['duration'] = timestamp_finish - timestamp_start
    fmt['Result'] = Result
    fmt['disqualified_teams'] = ""
    for team, error in scoreboard.disqualified_teams.items():
        fmt['disqualified_teams'] += f"<li><strong>{team}</strong>: {error}</li>"

    fmt['layout_info'] = "<h2>Layout information</h2>"
    if layout_type[0] != "map":
        fmt['layout_info'] += """<p>Each game is played on a random map. I will not list all possible maps.</p>"""
    else:
        fmt['layout_map'] = "\n".join(layout_type[1].layoutText)
        fmt['layout_info'] += """<p>Games are played on the
<strong>{layout_name}</strong> map. Below you will find an ASCII
representation of that map.
<figure class="layout">
<pre role="img" aria-label="An ASCII art representation of the used map.">
{layout_map}
</pre>
<figcaption>
<p>An ASCII art representation of the used map.</p>
</figcaption>
</figure>
""".format(**fmt)

    if len(fmt['disqualified_teams']):
        fmt['disqualified_teams'] = f"""
<p class="disqualified">The following teams are disqualified by initial inspection:
</p>
  <ul class="disqualified">
    {fmt['disqualified_teams']}
  </ul>"""

    fmt['game_outcomes'] = ''
    if scoreboard.participants:
        fmt['ranking'] = ""
        for i, (n, r) in enumerate(scoreboard.ranking()):
            s = r.score()
            fmt['ranking'] += f"""    <tr>
          <td>{i+1}</td>
          <td>{n}</td>
          <td class="points">{r.points}</td>
          <td class="win">{r.win}</td>
          <td class="tie">{r.tie}</td>
          <td class="lost">{r.lost}</td>
          <td class="error">{r.error}</td>
          <td class="score">{s}</td>
        </tr>
    """

        participants = scoreboard.participants
        header = ''
        subheader = len(participants) * """
          <th scope="col" class="points">Points</th>
          <th scope="col" class="win">Win</th>
          <th scope="col" class="tie">Tie</th>
          <th scope="col" class="lost">Lost</th>
          <th scope="col" class="error">Error</th>
    """
        fmt['game_outcomes'] = """
<h2>Team ranking</h2>
The team ranking is based on a total competition score.  Each result type is
worth a number of points, as can be seen in the table below.  In case of equal
competition scores, teams with more points collected will be ranked higher.
<table>
  <thead>
    <tr>
      <th>Outcome type</th>
      <th>Competition points</th>
    <tr>
  </thead>
  <tbody>
    <tr class="win">
      <td>Win</td>
      <td>{Result.WIN}</td>
    </tr>
    <tr class="tie">
      <td>Tie</td>
      <td>{Result.TIE}</td>
    </tr>
    <tr class="lost">
      <td>Lost</td>
      <td>{Result.LOST}</td>
    </tr>
    <tr class="error">
      <td>Error</td>
      <td>{Result.ERROR}</td>
    </tr>
  </tbody>
</table>

<table>
  <caption>Ranking of all qualified teams.</caption>
  <thead>
    <tr>
      <th>Position</th>
      <th>Team name</th>
      <th>Points</th>
      <th>Win</th>
      <th>Tie</th>
      <th>Lost</th>
      <th>Failed</th>
      <th>Competition score</th>
    </tr>
  </thead>
  <tbody>
{ranking}
  </tbody>
</table>
""".format(**fmt)


    if len(scoreboard.participants) > 1:
        results = ''

        for team in participants:
            header += f'    <th scope="colgroup" colspan="5">{team}</th>\n'
            results += '    <tr>\n'
            results += f'      <th scope="row">{team}</th>\n'
            for rival in participants:
                if rival == team:
                    results += '      <td colspan="5">&mdash;</td>\n'
                else:
                    r = scoreboard.records[team][rival]
                    results += f"""
          <td class="points">{r.points}</td>
          <td class="win">{r.win}</td>
          <td class="tie">{r.tie}</td>
          <td class="lost">{r.lost}</td>
          <td class="error">{r.error}</td>\n"""
            results += '    </tr>\n'
        fmt['results'] = f"""
        <tr>
          <td rowspan="2"></td>
          {header}
        </tr>
        <tr>
    {subheader}
        </tr>
    {results}"""
        fmt['game_outcomes'] += f"""

<h2>Results per matchup</h2>
<table>
  <caption>Results per competitor.</caption>
{fmt['results']}
</table>"""

    with open(report_file, 'w') as f:
        f.write("""<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<style>
.disqualified {{
  color: red;
}}
td, th {{
  text-align: center;
}}

th[scope="row"] {{
  text-align: right;
}}

.win {{
  background-color: lightgreen;
}}
.tie {{
  background-color: lavender;
}}
.lost {{
  background-color: lightblue;
}}
.error {{
  background-color: lightsalmon;
}}
.points {{
  background-color: lightgoldenrodyellow;
}}

td[colspan] {{
  background-color: lightgrey;
}}

caption, figcaption {{
  font-style: italic;
  text-align: center;
}}

.layout {{
  width: min-content;
}}

.layout > pre {{
  border: 2px solid lightgrey;
  padding: 0.5em;
  width: min-content;
}}
</style>
<title>{title}</title>
<meta name="generator" content="Julian and Patricks awesome competition script!">

</head>
<body>
<h1>{title}</h1>

<p>These are the results for a run of the Capture the Flag
competition, part of the course {courseName}. The simulation
started at {timestamp_start:%d-%m-%Y, %H:%M:%S}, and ended at
{timestamp_finish:%d-%m-%Y, %H:%M:%S}.
Running all simulations took {duration} time.  It was played on
the <strong>{layout_name}</strong> map.</p>

{disqualified_teams}

{game_outcomes}
<!-- This competition has been run with the following arguments:
     {argv}
-->
{layout_info}
</body>
</html>""".format(**fmt))


def select_file(directory: str, extension: str) -> str:
    """
    Select a file with extension in directory.

    If multiple matches are present, ask the user what to do.
    """
    files = []
    try:
        for filename in os.listdir(directory):
            if filename.endswith(extension):
                files.append(filename)
    except FileNotFoundError:
        pass
    if not files:
        msg = f"No files with extension {extension} found in {directory}"
        logging.error(msg)
        raise ValueError(msg)
    filename = files[0]
    if len(files) > 1:
        print("Multiple matching files present:")
        files.sort()
        padding = int(math.log10(len(files))) + 1
        fmt = f"{{:{padding}d}}.  {{}}"
        for i, f in enumerate(files):
            print(fmt.format(i, f))
        file_index = int(input("Choose your zip to upload: "))
        if file_index < 0 or file_index >= len(files):
            raise IndexError(f"Your input i should be 0 <= i < {len(files)}")
        filename = files[file_index]
    return os.path.join(directory, filename)


def zip_results(output_dir: str, remove_src=False) -> str:
    """
    Create a zip archive of the results.html and replay files.
    """
    zip_name = output_dir + ".zip"
    archive_dir = output_dir.split(os.sep)[-1]
    zf = zipfile.ZipFile(zip_name, mode='w')
    for f in os.listdir(output_dir):
        full_name = os.path.join(output_dir, f)
        archive_name = os.path.join(archive_dir, f)
        zf.write(full_name, archive_name)
    zf.close()

    if remove_src:
        for f in os.listdir(output_dir):
            os.remove(os.path.join(output_dir, f))
        os.rmdir(output_dir)

    return output_dir + ".zip"


## COMPETITION: SEND OUTPUT

def upload_to_teams(filename: str,
                    secrets: SecretsType,
                    remove_local=False,
                    chunk_size=9*2**20) -> bool:
    """
    Call a Microsoft Flow to transfer the results zip to Teams.

    A results zip is uploaded to the cloud over HTTP requests to a Flow.
    Because these HTTP requests have a maximum size which is lower than the
    size of a potential results zip, and because processing of binary data in
    Flow is a bit intransparant, we transform the zip first to a base64 encoded
    version.  This is transferred in chunks of chunk_size bytes (default: 9 MiB).
    On the first chunk, the Flow creates a new file.  It starts storing the base64
    encoded data, and when the final chunk is received, the Flow decodes the data.

    This process might take some time, but at least we know it's still running by
    reading the logs.

    For this, the following secrets are required:
        - flow_transfer_results_chunk
    """
    if not are_secrets_available(secrets, ['flow_transfer_results_chunk']):
        logging.warning("Secret information for uploading data to Teams insufficient.  "
                        "Students are not notified.")
        return False

    basename = filename.split(os.path.sep)[-1]
    logging.info(f"Filename to upload: '{basename}')")
    with open(filename, 'rb') as f:
        data = base64.b64encode(f.read())
    chunks = math.ceil(len(data) / chunk_size)
    ATTEMPTS = 3
    for attempt in range(ATTEMPTS):
        try:
            for chunk_index in range(chunks):
                chunk = data[chunk_index*chunk_size:(chunk_index+1)*chunk_size]
                logging.info(f"Uploading chunk {chunk_index+1} of {chunks}")
                call_flow(secrets, 'flow_transfer_results_chunk',
                        filename=basename,
                        content=chunk.decode('utf-8'),
                        chunk_index=chunk_index,
                        final_chunk=(chunk_index+1 == chunks))
        except urllib.error.HTTPError as e:
            if e.code == http.HTTPStatus.GATEWAY_TIMEOUT and attempt+1 < ATTEMPTS:
                logging.debug(f"Flow timed out: {e}")
                continue
            else:
                raise e
        else:
            break
    logging.info("Done uploading")
    if remove_local:
        os.remove(filename)
        logging.info(f"Removed {basename}")
    return True


def notify_students(results_file: str,
                    secrets: SecretsType,
                    remove_zip: bool) -> None:
    """
    Call a Flow to upload file and post a message to Microsoft Teams.

    The Flow is trigged by an HTTP PUT request, with a JSON payload,
    containing a 'filename', representing the name of the newly added file.

    The Flow will then handle the messaging part of students.  This could
    be something like sending a message to the appropriate channel on Teams.

    For this, the following secrets are required:
        - flow_notify
        - flow_transfer_results_chunk
    """
    if not are_secrets_available(secrets, ['flow_notify', 'flow_transfer_results_chunk']):
        logging.warning("Secret information for notifying student insufficient.  "
                        "Students are not notified.")
        return
    if not upload_to_teams(results_file, secrets, remove_local=remove_zip):
        logging.warning("Could not upload to Teams; did not notify students.")
        return

    filename = results_file.split(os.path.sep)[-1]

    call_flow(secrets, 'flow_notify', filename=filename)
    logging.info("Placed a notification on Teams.")


## COMPETITION: RUN MATCHES

def run_match(runner_id: int, args: argparse.Namespace, output_dir: str,
              match_queue: multiprocessing.Queue,
              results: multiprocessing.Queue,
              is_done: multiprocessing.Queue) -> None:
    """
    Worker for multithreading, runs a single match at a time.

    This function will prepare everything to make a call to capture.runGames
    for the matches in match_queue, a multiprocessing.Queue.  Results of
    capture.runGames are put into results, another multiprocessing.Queue.
    """
    while not match_queue.empty():
        try:
            matchno = match_queue.qsize()
            (red_name, red_factory), (blue_name, blue_factory) = match_queue.get(timeout=1)
            match_log = create_match_log(output_dir, matchno, red_name, blue_name)
            msg = f"Playing match {matchno}: {red_name} vs {blue_name}"
            match_log.info(msg)
            red_result = Result.WIN
            blue_result = Result.WIN

            if args.fixRandomSeed:
                random.seed('cs188')

            # Create agents, check on errors in this part.
            red_agents = None
            blue_agents = None
            try:
                with silence_stdout():
                    red_agents = mute_agents(red_factory(0, 2, True,
                        **args.agentArgs))
            except Exception:
                red_result = Result.ERROR
            try:
                with silence_stdout():
                    blue_agents = mute_agents(blue_factory(1, 3, False,
                        **args.agentArgs))
            except Exception:
                blue_result = Result.ERROR

            if Result.ERROR in (red_result, blue_result):
                err_msg = "Match {}: An error occured during {}'s createTeam"
                if red_result == Result.ERROR:
                    msg = err_msg.format(matchno, red_name)
                    match_log.error(msg)
                if blue_result == Result.ERROR:
                    msg = err_msg.format(matchno, blue_name)
                    match_log.error(msg)
                red_label = Result.get_name(red_result)
                blue_label = Result.get_name(blue_result)
                msg = f"{red_name} vs {blue_name} ended in {red_label}-{blue_label} with 0 pts"
                match_log.info(msg)
                for _ in range(args.numGames):
                    results.put((red_name, blue_name, 0, red_result, blue_result))
                continue

            # Play the game!
            _args = update_arguments(args, red_name, red_agents, blue_name, blue_agents)
            with tempfile.TemporaryDirectory(prefix=f"pacman-{matchno}-{red_name}-{blue_name}-") as tmpdirname:
                curdir = os.path.abspath(os.curdir)
                with log_stdout(logname=match_log.name):
                    with log_stderr(logname=match_log.name):
                        os.chdir(tmpdirname)
                        games = capture.runGames(**_args)
                        os.chdir(curdir)

                # Update the global score card.
                points = [(game.state.data.score, game.agentCrashed or game.agentTimeout)
                        for game in games]

                for point, error in points:
                    red_result, blue_result = Result.from_points(point, error)
                    red_label = Result.get_name(red_result)
                    blue_label = Result.get_name(blue_result)
                    msg = f"{red_name} vs {blue_name} ended in {red_label}-{blue_label} with {point} pts"
                    match_log.info(msg)
                    results.put((red_name, blue_name, point, red_result, blue_result))

                # Move all replay-% files to DATA_PATH/results/replay-matchno-red_name-blue_name-%d
                match_name = os.path.join(output_dir, f"replay-{matchno}-{red_name}-{blue_name}")
                replay_prefix = 'replay'
                replay_files = filter(lambda s: s.startswith(replay_prefix + '-'),
                        os.listdir(tmpdirname))
                for filename in replay_files:
                    new_name = match_name + filename[len(replay_prefix):]
                    shutil.move(os.path.join(tmpdirname, filename), os.path.join(DATA_PATH, new_name))
        except multiprocessing.queues.Empty:
            break
    is_done.put(runner_id)


def import_students() -> ModuleType:
    """
    Import student code from unzipped archive.

    Temporary modifications to sys.path are made that only last within the
    scope of this function.

    To avoid students playing with the __init__ file, overwrite
    DATA_PATH/students/__init__.py with a fresh version every time.
    """
    shutil.copy(os.path.join(os.path.dirname(__file__),
                             '_students_init.py'),
                os.path.join(DATA_PATH, 'students', '__init__.py'))
    old_path = sys.path
    sys.path = [DATA_PATH] + sys.path
    import students
    sys.path = old_path
    return students


def run_competition(args: argparse.Namespace) -> None:
    """
    Run a competition of capture.runGames, generates a report and notifies
    contestants.

    args is the return value of parse_arguments().  See that function to know
    all the options and their meaning.
    """
    logging.info("Starting.")
    args.timestamp_start = datetime.datetime.now()
    if RUNNING_IN_CONTAINER and args.display_type != 'super_quiet':
        t: datetime.datetime = args.timestamp_start
        print(f"Started running at {t.time()}, {t.date()}")
    scoreboard = Scoreboard()
    secrets = load_secrets(args.secrets, args)
    has_new_data = False

    if args.do_download:
        has_new_data = receive_student_data(secrets)
    if args.add_baseline:
        add_baseline_to_pool(secrets)
    # You must import students after receive_student_data(), because you will
    # probably download new submodules.
    students = import_students()
    disqualified_on_import = {m: StudentError.CannotImport.format(err)
                              for m, err in students._IMPORT_ERRORS}
    scoreboard.disqualify(disqualified_on_import)
    student_modules = get_student_modules(students)
    agent_factories, disqualified_teams = analyse_student_modules(student_modules)

    output_dir = args.timestamp_start.strftime(os.path.join(DATA_PATH,
                                                            "results",
                                                            f"{TIMESTAMP_FMT}-{args.layout}"))
    if args.play_matches:
        if args.do_download and not has_new_data:
            logging.info("Downloaded data, but it's the same as the last time; no competition is run")
            return

        scoreboard.disqualify(disqualified_teams)
        scoreboard.register_participants(agent_factories)

        if scoreboard.disqualified_teams:
            logging.info("{} disqualified team{}:".format(len(scoreboard.disqualified_teams),
                                                          "" if len(scoreboard.participants) == 1 else "s"))
            for name, reason in scoreboard.disqualified_teams.items():
                logging.info(f"  - {name}: {reason}")
        logging.info("{} qualified team{}: {}".format(len(scoreboard.participants),
                                                      "" if len(scoreboard.participants) == 1 else "s",
                                                      ", ".join(scoreboard.participants)))
        if len(scoreboard.student_participants) < 1:
            logging.info("Only {} true participating team{} (non-[git], non-veterans); no competition is run".format(
                len(scoreboard.student_participants),
                "" if len(scoreboard.student_participants) == 1 else "s"
            ))
            return

        try:
            os.makedirs(output_dir)
        except FileExistsError:
            pass

        matches = scoreboard.make_pairings(focus=args.focus)
        n = len(scoreboard.participants)
        match_count = int(math.factorial(n) / math.factorial(2) / math.factorial(n-2))
        if args.focus:
            match_count = 2*n-2
        match_count *= args.numGames
        padding = int(math.log10(match_count))+1
        loading_bar = f"\r Matches finished: {{:{padding}}}/{match_count}"
        match_runners = {}
        results = multiprocessing.Queue()
        is_done = multiprocessing.Queue()
        logging.info(f"A total of {matches.qsize()} matches will be played. Counting down")
        for i in range(args.threads):
            p = multiprocessing.Process(target=run_match,
                    args=(i, args, output_dir, matches, results, is_done))
            match_runners[i] = p
            p.start()

        while match_runners:
            if not is_done.empty():
                name = is_done.get(timeout=1)
                match_runners[name].join()
                del match_runners[name]
            # Periodically move results to scoreboard, so that results is not overflowing.
            while not results.empty():
                scoreboard.add_result(*results.get())
            if args.display_type != 'super_quiet':
                print(loading_bar.format(len(scoreboard)), end='')
            time.sleep(0.1)
        if args.display_type != 'super_quiet':
            print("")

        args.timestamp_finish = datetime.datetime.now()
        report_file = os.path.join(output_dir, "scoreboard.html")
        course_name = secrets.get('course_name', "UNKNOWN")
        generate_html_report(scoreboard, report_file, course_name,
                **vars(args))
        zip_name = zip_results(output_dir, remove_src=True)
    else:
        if args.send_message:
            zip_name = select_file(os.path.dirname(output_dir), ".zip")

    if args.send_message:
        notify_students(zip_name, secrets, args.remove_zip)
    logging.info("Done!")


if __name__ == "__main__":
    args = parse_arguments()
    if args.edit_secrets:
        create_secrets(args.secrets)
    else:
        try:
            run_competition(args)
        except Exception as e:
            logging.error(f"{e}")
            raise e
